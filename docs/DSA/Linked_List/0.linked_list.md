---
title: Single Linked list
url: https://hackmd.io/ZYIl39ytQSSk8ncizybgdQ
lastSync: 2025-06-25T14:24:39.798Z
up: "[[DSA&ALG]]"
---
# Single Linked list

我們先實作一個簡單的 linked list，我們使用 `main.c` 來撰寫主要的測試 case ， `list.h` 來定義 linked list 的結構和函式原型， `list.c` 來實作 linked list 的函式。完整的程式可以參考 [code](https://github.com/alanhc/algorithm/tree/main/dsa/linked_list)。

## 實作 linked list 的新增、刪除

先建立以下檔案：

```bash
.
├── list.c
├── list.h
└── main.c
```

### `main.c`：主要的程式入口
在 `main.c` 中，我們會先撰寫整個程式的主要邏輯跟所需要的函式。這裡我們使用 `dummy head node` 來簡化 linked list 的操作，這樣可以避免處理空 linked list 的情況。

:::info
由以下圖可知，如果沒有 dummy head node，當 linked list 為空時，head 會指向 NULL，這樣在插入或刪除節點時需要特別處理空 linked list 的情況。而有了 dummy head node 後，head 永遠不會是 NULL，這樣就可以簡化程式碼。
```
A. 沒有 dummy                                B. 有 dummy
┌────┐    ┌────┐    ┌────┐                ┌────┐    ┌────┐    ┌────┐
│ 1  │──▶ │ 2  │──▶ │ 3  │                │ D  │──▶ │ 1  │──▶ │ 2  │──▶ │ 3  │
└────┘    └────┘    └────┘                └────┘    └────┘    └────┘
 head                                       head(固定指向 D)
```
:::

```c
int main()
{
    Node *head = create_node(-1); // create a dummy head node
    // create a linked list with 5 nodes
    // insert 5 nodes at the tail
    for (int i=0; i<5; i++)
    {
        insert_tail(head, i);
    }
    print_list(head);
    // insert 5 nodes at the head
    for (int i=5; i<10; i++)
    {
        insert_head(head, i);
    }
    print_list(head);
    
    // delete the specific node with value 3
    delete_node(head, 3);
    print_list(head);
    
    // delete the middle node
    delete_mid(head);

    print_list(head);
    free_list(head);

    // delete the duplicate nodes
    head = create_node(-1);
    for (int i=0; i<5; i++)
    {
        for (int j=0; j<2; j++) {
            insert_tail(head, i);
        }
    }
    print_list(head);
    delete_dup(head);
    print_list(head);
    return 0;
}
```

### 在 `list.h` 定義的結構和函式原型：

```c
typedef struct Node
{
    int data;
    struct Node *next;
} Node;

Node* create_node(int n);
void free_list(Node *node);
void print_list(Node *node);
void insert_tail(Node *node, int n);
void insert_head(Node *node, int n);
void delete_node(Node *node, int n);
void delete_head(Node *node);
void delete_tail(Node *node);
void delete_mid(Node *node);
void delete_dup(Node *node);
```

### `list.c` 基本的建立節點及結構
宣告 `Node` 結構，在 `list.h` 中定義 linked list 的節點結構，包含 `data` 和 `next` 指標。
![alt text](assets/image-2.png)
```c
typedef struct Node
{
    int data;
    struct Node *next;
} Node;
```
建立節點
```c
Node* create_node(int n)
{
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = n;
    node->next = NULL;
    return node;
}
```

### 在 `list.c` 實作新增到尾
先找到 linked list 的尾端，然後將新的節點插入到尾端。
```c
void insert_tail(Node* node, int n)
{
    // 找到 linked list 的尾端
    while (node->next != NULL)
    {
        node = node->next;
    }
    // 在尾端插入新的節點
    node->next = create_node(n);
}
```
### 在 `list.c` 實作新增到頭
![alt text](assets/image.png)
```c
void insert_head(Node* dummy, int value)
{
    printf("insert head %d\n", value);
    Node* new_node = create_node(value);       // 建立新節點
    new_node->next = dummy->next;              // 指向原本第一個節點
    dummy->next = new_node;                    // dummy 指向新的第一個節點
}
```
### 實作刪除特定節點
![alt text](assets/image-3.png)
```c
void delete_node(Node* node, int n)
{
    printf("delete node %d\n", n);
    Node* pre = node;
    node = node->next; // 跳過 dummy head
    while (node!=NULL)
    {
        // 如果找到要刪除的節點
        if (node->data==n) {
            pre->next = node->next;
            free(node);
            return;
        }
        // 如果沒有找到，繼續往下走
        pre = node; 
        node = node->next;
    }
}
```

## 編譯
```
gcc -Wall -o linked_list.out main.c list.c 
```
- `-Wall` 參數會開啟所有警告訊息，這樣可以幫助我們在編譯時發現潛在的問題。
- `-o linked_list.out` 參數指定輸出的可執行檔名稱為 `linked_list.out`。
- `gcc` 是 GNU C Compiler 的縮寫，是一個開源的 C 語言編譯器。
會產生 `linked_list.out` 可執行檔。

## 執行
```
$ ./linked_list.out 
-1 0 1 2 3 4 
```

TODO
remove_head
remove_tail
delete_mid
delete_dup
swap
reverse
reverseK
sort
ascend
descend
merge